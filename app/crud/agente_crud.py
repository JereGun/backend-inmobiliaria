from sqlalchemy.orm import Session
from sqlalchemy.orm import Session # Ensure Session is imported
from app.models.agente import Agente
from app.models.usuario import Usuario # Import Usuario model
from app.schemas.agente import AgenteCreate, AgenteUpdate
from app.schemas.usuario import UsuarioUpdate as SchemaUsuarioUpdate # For the update method
from app.crud.usuario_crud import usuario as crud_usuario # Import user CRUD
from app.core.security import get_password_hash # Import for hashing password

class CRUDAgente:
    def get(self, db: Session, id: int):
        # This should still work due to joined table inheritance.
        # SQLAlchemy handles fetching data from both tables.
        return db.query(Agente).filter(Agente.id == id).first()

    def get_multi(self, db: Session, *, skip: int = 0, limit: int = 100):
        return db.query(Agente).offset(skip).limit(limit).all()

    def create(self, db: Session, *, obj_in: AgenteCreate) -> Agente:
        # All data for User and Agente parts is in obj_in (AgenteCreate schema)
        agente_model_data = obj_in.model_dump(exclude_none=True) # Get all fields from AgenteCreate

        # Separate password to hash it, and remove plain password from data to be passed to model
        plain_password = agente_model_data.pop("password", None)
        if not plain_password:
            # This case should ideally be caught by Pydantic validation of AgenteCreate
            raise ValueError("Password is required for Agente creation")

        hashed_pwd = get_password_hash(plain_password)

        # Create the Agente instance with all data
        # User fields (email) will be set from agente_model_data.
        # Agente-specific fields will also be set from agente_model_data.
        # is_active and is_superuser will use defaults from Usuario model unless provided in AgenteCreate

        # Prepare data for Agente model, excluding fields not directly on Agente or Usuario if AgenteCreate has extra fields.
        # For now, assume AgenteCreate fields align with Agente model attributes (+ password).

        # Check if AgenteCreate schema includes is_active, is_superuser directly.
        # Current AgenteCreate does not, so they'll rely on Usuario model defaults.
        # If AgenteCreate were to include them:
        # user_specific_fields = {}
        # if 'is_active' in agente_model_data:
        #     user_specific_fields['is_active'] = agente_model_data.pop('is_active')
        # if 'is_superuser' in agente_model_data:
        #     user_specific_fields['is_superuser'] = agente_model_data.pop('is_superuser')

        db_obj = Agente(
            **agente_model_data,  # Contains email, nombre, apellido, etc.
            hashed_password=hashed_pwd
            # **user_specific_fields # if is_active/is_superuser were on AgenteCreate
            # id will be auto-generated by Usuario table and used for Agente table
        )

        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def update(
        self, db: Session, *, db_obj: Agente, obj_in: AgenteUpdate
    ) -> Agente:
        # obj_in comes from AgenteUpdate schema
        update_data_agente = {} # For Agente specific fields
        update_data_usuario = {} # For Usuario specific fields

        obj_in_dump = obj_in.model_dump(exclude_unset=True)

        # Iterate over fields in the incoming update schema
        for field, value in obj_in_dump.items():
            if hasattr(Usuario, field) and field not in ["id"]: # Check if it's a Usuario field
                # password needs special handling (hashing)
                if field == "password":
                    if value: # Ensure password is not empty or None
                        update_data_usuario["hashed_password"] = get_password_hash(value)
                    # Do not put plain password in update_data_usuario
                elif field in ["email", "is_active", "is_superuser"]:
                     update_data_usuario[field] = value
                # else: ignore other Usuario fields not typically updated this way (e.g. hashed_password directly)

            # If not a User field (or handled above), assume it's an Agente specific field
            # or a field on Agente that shadows a User field (like 'activo' vs 'is_active')
            elif hasattr(Agente, field) and field != "id":
                update_data_agente[field] = value

        # Update Agente specific fields on db_obj (the Agente instance)
        for field, value in update_data_agente.items():
            setattr(db_obj, field, value)

        # Fetch the associated User instance to update its fields
        if update_data_usuario:
            user_to_update = crud_usuario.get_user(db, user_id=db_obj.id)
            if not user_to_update:
                raise Exception("User not found for this Agente during update") # Should not happen

            for field, value in update_data_usuario.items():
                 setattr(user_to_update, field, value)
            db.add(user_to_update) # Add user to session if fields were changed

        db.add(db_obj) # Add agente to session if fields were changed or to link with user changes
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def remove(self, db: Session, *, id: int) -> Agente:
        # When removing an Agente, we also need to remove the associated User.
        # The Agente model has a ForeignKey to Usuario, but the deletion isn't cascaded by default
        # at the database level unless specified in SQLAlchemy relationship or table args.
        # It's often safer to handle this explicitly in code.

        agente_obj = db.query(Agente).get(id)
        if not agente_obj:
            return None # Or raise exception

        user_id = agente_obj.id # Agente.id is the user_id

        db.delete(agente_obj)
        # db.commit() # Commit Agente deletion

        # Now delete the user
        user_obj = crud_usuario.get_user(db, user_id=user_id)
        if user_obj:
            db.delete(user_obj)

        db.commit() # Commit both deletions (or user deletion)
        return agente_obj # Return the deleted Agente object (now detached)

agente = CRUDAgente()
